// index.js
const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const Book = require('./models/Book');
const Transaction = require('./models/Transaction');
const User = require('./models/User');

const app = express();
app.use(bodyParser.json());

mongoose.connect('mongodb://localhost:27017/libraryDB', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log('Connected to MongoDB'))
.catch(err => console.error('MongoDB connection error:', err));

const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});


// Get books by name or term
app.get('/books/search', async (req, res) => {
  const { term } = req.query;
  try {
    const books = await Book.find({ name: new RegExp(term, 'i') });
    res.status(200).json(books);
  } catch (error) {
    res.status(500).json({ error: 'Error searching books' });
  }
});

// Get books by rent price range
app.get('/books/rent', async (req, res) => {
  const { minRent, maxRent } = req.query;
  try {
    const books = await Book.find({
      rentPerDay: { $gte: parseInt(minRent), $lte: parseInt(maxRent) }
    });
    res.status(200).json(books);
  } catch (error) {
    res.status(500).json({ error: 'Error fetching books by rent range' });
  }
});

// Search books by category + name (term) + and rent range
app.get('/books/search-combined', async (req, res) => {
  const { category, term, minRent, maxRent } = req.query;

  const query = {};
  if (category) query.category = category;
  if (term) query.name = new RegExp(term, 'i');
  if (minRent && maxRent) {
    query.rentPerDay = { $gte: parseInt(minRent), $lte: parseInt(maxRent) };
  }

  try {
    const books = await Book.find(query);
    res.status(200).json(books);
  } catch (error) {
    res.status(500).json({ error: 'Error searching books' });
  }
});

// Issue a book
app.post('/transactions/issue', async (req, res) => {
  const { bookId, userId, issueDate } = req.body;

  try {
    const book = await Book.findById(bookId);
    const user = await User.findById(userId);

    if (!book || !user) {
      return res.status(404).json({ error: 'Book or User not found' });
    }

    const transaction = new Transaction({ bookId, userId, issueDate });
    await transaction.save();

    res.status(201).json({ message: 'Book issued successfully' });
  } catch (error) {
    res.status(500).json({ error: 'Error issuing book' });
  }
});

// Return a book
app.post('/transactions/return', async (req, res) => {
  const { bookId, userId, returnDate } = req.body;

  try {
    const transaction = await Transaction.findOne({ bookId, userId, returnDate: null });

    if (!transaction) {
      return res.status(404).json({ error: 'Transaction not found' });
    }

    const book = await Book.findById(bookId);
    const issueDate = new Date(transaction.issueDate);
    const returnDateObj = new Date(returnDate);
    const daysRented = Math.ceil((returnDateObj - issueDate) / (1000 * 60 * 60 * 24));
    const rentAmount = daysRented * book.rentPerDay;

    transaction.returnDate = returnDateObj;
    transaction.rentAmount = rentAmount;
    await transaction.save();

    res.status(200).json({ message: 'Book returned successfully', rentAmount });
  } catch (error) {
    res.status(500).json({ error: 'Error returning book' });
  }
});

// Get book issuance details
app.get('/transactions/book/:bookId', async (req, res) => {
  const { bookId } = req.params;

  try {
    const transactions = await Transaction.find({ bookId }).populate('userId');
    const currentlyIssued = transactions.find(t => !t.returnDate);
    const totalCount = transactions.length;

    const response = {
      totalCount,
      currentlyIssued: currentlyIssued ? currentlyIssued.userId : null,
      status: currentlyIssued ? 'Issued' : 'Not Issued'
    };

    res.status(200).json(response);
  } catch (error) {
    res.status(500).json({ error: 'Error fetching book issuance details' });
  }
});

// Get total rent generated by a book
app.get('/transactions/rent/:bookId', async (req, res) => {
  const { bookId } = req.params;

  try {
    const transactions = await Transaction.find({ bookId, returnDate: { $ne: null } });
    const totalRent = transactions.reduce((sum, t) => sum + (t.rentAmount || 0), 0);

    res.status(200).json({ totalRent });
  } catch (error) {
    res.status(500).json({ error: 'Error calculating total rent' });
  }
});

// Get books issued to a person
app.get('/transactions/user/:userId', async (req, res) => {
  const { userId } = req.params;

  try {
    const transactions = await Transaction.find({ userId }).populate('bookId');
    const books = transactions.map(t => t.bookId);

    res.status(200).json(books);
  } catch (error) {
    res.status(500).json({ error: 'Error fetching issued books' });
  }
});

// Get books issued in a date range
app.get('/transactions/date-range', async (req, res) => {
  const { startDate, endDate } = req.query;

  try {
    const transactions = await Transaction.find({
      issueDate: { $gte: new Date(startDate), $lte: new Date(endDate) }
    }).populate('bookId userId');

    const results = transactions.map(t => ({
      book: t.bookId,
      issuedTo: t.userId
    }));

    res.status(200).json(results);
  } catch (error) {
    res.status(500).json({ error: 'Error fetching books issued in date range' });
  }
});